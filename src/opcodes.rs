//!
//! Generic instructions, generated by the compiler.  If any of them change number,
//! arity or semantics, the format number above must be bumped.
//!
//! name can optionally be preceded by - to indicate that it has been obsoleted. The compiler is not allowed to generate BEAM files that use obsolete instructions and the loader will refuse to load BEAM files that use obsolete instructions.
#![allow(dead_code)]
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Opcode {
    /// @spec label Lbl
    /// @doc Specify a module local label.
    ///      Label gives this code address a name (Lbl) and marks the start of
    ///      a basic block.
    Label = 1,

    /// @spec func_info M F A
    /// @doc Define a function M:F/A
    FuncInfo = 2,

    IntCodeEnd = 3,

    //
    // Function and BIF calls.
    //
    /// @spec call Arity Label
    /// @doc Call the function at Label.
    ///      Save the next instruction as the return address in the CP register.
    Call = 4,

    /// @spec call_last Arity Label Deallocate
    /// @doc Deallocate and do a tail recursive call to the function at Label.
    ///      Do not update the CP register.
    ///      Before the call deallocate Deallocate words of stack.
    CallLast = 5,

    /// @spec call_only Arity Label
    /// @doc Do a tail recursive call to the function at Label.
    ///      Do not update the CP register.
    CallOnly = 6,

    /// @spec call_ext Arity Destination
    /// @doc Call the function of arity Arity pointed to by Destination.
    ///      Save the next instruction as the return address in the CP register.
    CallExt = 7,

    /// @spec call_ext_last Arity Destination Deallocate
    /// @doc Deallocate and do a tail call to function of arity Arity
    ///      pointed to by Destination.
    ///      Do not update the CP register.
    ///      Deallocate Deallocate words from the stack before the call.
    CallExtLast = 8,

    /// @spec bif0 Bif Reg
    /// @doc Call the bif Bif and store the result in Reg.
    Bif0 = 9,

    /// @spec bif1 Lbl Bif Arg Reg
    /// @doc Call the bif Bif with the argument Arg, and store the result in Reg.
    ///      On failure jump to Lbl.
    Bif1 = 10,

    /// @spec bif2 Lbl Bif Arg1 Arg2 Reg
    /// @doc Call the bif Bif with the arguments Arg1 and Arg2,
    ///      and store the result in Reg.
    ///      On failure jump to Lbl.
    Bif2 = 11,

    //
    // Allocating, deallocating and returning.
    //
    /// @spec allocate StackNeed Live
    /// @doc Allocate space for StackNeed words on the stack. If a GC is needed
    ///      during allocation there are Live number of live X registers.
    ///      Also save the continuation pointer (CP) on the stack.
    Allocate = 12,

    /// @spec allocate_heap StackNeed HeapNeed Live
    /// @doc Allocate space for StackNeed words on the stack and ensure there is
    ///      space for HeapNeed words on the heap. If a GC is needed
    ///      save Live number of X registers.
    ///      Also save the continuation pointer (CP) on the stack.
    AllocateHeap = 13,

    /// @spec allocate_zero StackNeed Live
    /// @doc Allocate space for StackNeed words on the stack. If a GC is needed
    ///      during allocation there are Live number of live X registers.
    ///      Clear the new stack words. (By writing NIL.)
    ///      Also save the continuation pointer (CP) on the stack.
    AllocateZero = 14,

    /// @spec allocate_heap_zero StackNeed HeapNeed Live
    /// @doc Allocate space for StackNeed words on the stack and HeapNeed words
    ///      on the heap. If a GC is needed
    ///      during allocation there are Live number of live X registers.
    ///      Clear the new stack words. (By writing NIL.)
    ///      Also save the continuation pointer (CP) on the stack.
    AllocateHeapZero = 15,

    /// @spec test_heap HeapNeed Live
    /// @doc Ensure there is space for HeapNeed words on the heap. If a GC is needed
    ///      save Live number of X registers.
    TestHeap = 16,

    /// @spec init N
    /// @doc  Clear the Nth stack word. (By writing NIL.)
    Init = 17,

    /// @spec deallocate N
    /// @doc  Restore the continuation pointer (CP) from the stack and deallocate
    ///       N+1 words from the stack (the + 1 is for the CP).
    Deallocate = 18,

    /// @spec return
    /// @doc  Return to the address in the continuation pointer (CP).
    Return = 19,

    //
    // Sending & receiving.
    //
    /// @spec send
    /// @doc  Send argument in x(1) as a message to the destination process in x(0).
    ///       The message in x(1) ends up as the result of the send in x(0).
    Send = 20,

    /// @spec remove_message
    /// @doc  Unlink the current message from the message queue. Remove any timeout.
    RemoveMessage = 21,

    /// @spec timeout
    /// @doc  Reset the save point of the mailbox and clear the timeout flag.
    Timeout = 22,

    /// @spec loop_rec Label Source
    /// @doc  Loop over the message queue, if it is empty jump to Label.
    LoopRec = 23,

    /// @spec loop_rec_end Label
    /// @doc  Advance the save pointer to the next message and jump back to Label.
    LoopRecEnd = 24,

    /// @spec wait Label
    /// @doc  Suspend the processes and set the entry point to the beginning of the
    ///       receive loop at Label.
    Wait = 25,

    /// @spec wait_timeout Lable Time
    /// @doc  Sets up a timeout of Time milliseconds and saves the address of the
    ///       following instruction as the entry point if the timeout triggers.
    WaitTimeout = 26,

    //
    // Arithmetic opcodes.
    //
    // -M_PLUS = 27,
    // -M_MINUS = 28,
    // -M_TIMES = 29,
    // -M_DIV = 30,
    // -INT_DIV = 31,
    // -INT_REM = 32,
    // -INT_BAND = 33,
    // -INT_BOR = 34,
    // -INT_BXOR = 35,
    // -INT_BSL = 36,
    // -INT_BSR = 37,
    // -INT_BNOT = 38,

    //
    // Comparision operators.
    //
    /// @spec is_lt Lbl Arg1 Arg2
    /// @doc Compare two terms and jump to Lbl if Arg1 is not less than Arg2.
    IsLt = 39,

    /// @spec is_ge Lbl Arg1 Arg2
    /// @doc Compare two terms and jump to Lbl if Arg1 is less than Arg2.
    IsGe = 40,

    /// @spec is_eq Lbl Arg1 Arg2
    /// @doc Compare two terms and jump to Lbl if Arg1 is not (numerically) equal to Arg2.
    IsEq = 41,

    /// @spec is_ne Lbl Arg1 Arg2
    /// @doc Compare two terms and jump to Lbl if Arg1 is (numerically) equal to Arg2.
    IsNe = 42,

    /// @spec is_eq_exact Lbl Arg1 Arg2
    /// @doc Compare two terms and jump to Lbl if Arg1 is not exactly equal to Arg2.
    IsEqExact = 43,

    /// @spec is_ne_exact Lbl Arg1 Arg2
    /// @doc Compare two terms and jump to Lbl if Arg1 is exactly equal to Arg2.
    IsNeExact = 44,

    //
    // Type tests.
    //
    /// @spec is_integer Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not an integer.
    IsInteger = 45,

    /// @spec is_float Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a float.
    IsFloat = 46,

    /// @spec is_number Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a number.
    IsNumber = 47,

    /// @spec is_atom Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not an atom.
    IsAtom = 48,

    /// @spec is_pid Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a pid.
    IsPid = 49,

    /// @spec is_reference Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a reference.
    IsReference = 50,

    /// @spec is_port Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a port.
    IsPort = 51,

    /// @spec is_nil Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not nil.
    IsNil = 52,

    /// @spec is_binary Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a binary.
    IsBinary = 53,

    // -IS_CONSTANT = 54,
    /// @spec is_list Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a cons or nil.
    IsList = 55,

    /// @spec is_nonempty_list Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a cons.
    IsNonemptyList = 56,

    /// @spec is_tuple Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a tuple.
    IsTuple = 57,

    /// @spec test_arity Lbl Arg1 Arity
    /// @doc Test the arity of (the tuple in) Arg1 and jump
    /// to Lbl if it is not equal to Arity.
    TestArity = 58,

    //
    // Indexing & jumping.
    //
    /// @spec select_val Arg FailLabel Destinations
    /// @doc Jump to the destination label corresponding to Arg
    ///      in the Destinations list, if no arity matches, jump to FailLabel.
    SelectVal = 59,

    /// @spec select_tuple_arity Tuple FailLabel Destinations
    /// @doc Check the arity of the tuple Tuple and jump to the corresponding
    ///      destination label, if no arity matches, jump to FailLabel.
    SelectTupleArity = 60,

    /// @spec jump Label
    /// @doc Jump to Label.
    Jump = 61,

    //
    // Catch.
    //
    Catch = 62,
    CatchEnd = 63,

    //
    // Moving, extracting, modifying.
    //
    /// @spec move Source Destination
    /// @doc Move the source Source (a literal or a register) to
    ///      the destination register Destination.
    Move = 64,

    /// @spec get_list  Source Head Tail
    /// @doc  Get the head and tail (or car and cdr) parts of a list
    ///       (a cons cell) from Source and put them into the registers
    ///       Head and Tail.
    GetList = 65,

    /// @spec get_tuple_element Source Element Destination
    /// @doc  Get element number Element from the tuple in Source and put
    ///       it in the destination register Destination.
    GetTupleElement = 66,

    /// @spec set_tuple_element NewElement Tuple Position
    /// @doc  Update the element at position Position of the tuple Tuple
    ///       with the new element NewElement.
    SetTupleElement = 67,

    //
    // Building terms.
    //
    // -PUT_STRING = 68,
    PutList = 69,
    PutTuple = 70,
    Put = 71,

    //
    // Raising errors.
    //
    Badmatch = 72,
    IfEnd = 73,
    CaseEnd = 74,

    //
    // 'fun' support.
    //
    /// @spec call_fun Arity
    /// @doc Call a fun of arity Arity. Assume arguments in
    ///      registers x(0) to x(Arity-1) and that the fun is in x(Arity).
    ///      Save the next instruction as the return address in the CP register.
    CallFun = 75,

    // -MAKE_FUN = 76,
    /// @spec is_function Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a
    ///      function (i.e. fun or closure).
    IsFunction = 77,

    //
    // Late additions to R5.
    //
    /// @spec call_ext_only Arity Label
    ///      Do a tail recursive call to the function at Label.
    ///      Do not update the CP register.
    CallExtOnly = 78,

    //
    // Binary matching (R7).
    //
    // -BS_START_MATCH = 79,
    // -BS_GET_INTEGER = 80,
    // -BS_GET_FLOAT = 81,
    // -BS_GET_BINARY = 82,
    // -BS_SKIP_BITS = 83,
    // -BS_TEST_TAIL = 84,
    // -BS_SAVE = 85,
    // -BS_RESTORE = 86,

    //
    // Binary construction (R7A).
    //
    // -BS_INIT = 87,
    // -BS_FINAL = 88,
    BsPutInteger = 89,
    BsPutBinary = 90,
    BsPutFloat = 91,
    BsPutString = 92,

    //
    // Binary construction (R7B).
    //
    // -BS_NEED_BUF = 93,

    //
    // Floating point arithmetic (R8).
    //
    Fclearerror = 94,
    Fcheckerror = 95,
    Fmove = 96,
    Fconv = 97,
    Fadd = 98,
    Fsub = 99,
    Fmul = 100,
    Fdiv = 101,
    Fnegate = 102,

    // New fun construction (R8).
    MakeFun2 = 103,

    // Try/catch/raise (R10B).
    Try = 104,
    TryEnd = 105,
    TryCase = 106,
    TryCaseEnd = 107,
    Raise = 108,

    // New instructions in R10B.
    BsInit2 = 109,
    // -BS_BITS_TO_BYTES = 110,
    BsAdd = 111,
    Apply = 112,
    ApplyLast = 113,
    /// @spec is_boolean Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a Boolean.
    IsBoolean = 114,

    // New instructions in R10B-6.
    /// @spec is_function2 Lbl Arg1 Arity
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a
    ///      function of arity Arity.
    IsFunction2 = 115,

    // New bit syntax matching in R11B.
    BsStartMatch2 = 116,
    BsGetInteger2 = 117,
    BsGetFloat2 = 118,
    BsGetBinary2 = 119,
    BsSkipBits2 = 120,
    BsTestTail2 = 121,
    BsSave2 = 122,
    BsRestore2 = 123,

    // New GC bifs introduced in R11B.
    /// @spec gc_bif1 Lbl Live Bif Arg Reg
    /// @doc Call the bif Bif with the argument Arg, and store the result in Reg.
    ///      On failure jump to Lbl.
    ///      Do a garbage collection if necessary to allocate space on the heap
    ///      for the result (saving Live number of X registers).
    GcBif1 = 124,

    /// @spec gc_bif2 Lbl Live Bif Arg1 Arg2 Reg
    /// @doc Call the bif Bif with the arguments Arg1 and Arg2,
    ///      and store the result in Reg.
    ///      On failure jump to Lbl.
    ///      Do a garbage collection if necessary to allocate space on the heap
    ///      for the result (saving Live number of X registers).
    GcBif2 = 125,

    // Experimental new bit_level bifs introduced in R11B.
    // NOT used in R12B.
    // -BS_FINAL2 = 126,
    // -BS_BITS_TO_BYTES2 = 127,

    // R11B-4
    // -PUT_LITERAL = 128,

    // R11B-5
    /// @spec is_bitstr Lbl Arg1
    /// @doc Test the type of Arg1 and jump to Lbl if it is not a bit string.
    IsBitstr = 129,

    // R12B
    BsContextToBinary = 130,
    BsTestUnit = 131,
    BsMatchString = 132,
    BsInitWritable = 133,
    BsAppend = 134,
    BsPrivateAppend = 135,

    /// @spec trim N Remaining
    /// @doc Reduce the stack usage by N words,
    ///      keeping the CP on the top of the stack.
    Trim = 136,

    BsInitBits = 137,

    // R12B-5
    BsGetUtf8 = 138,
    BsSkipUtf8 = 139,

    BsGetUtf16 = 140,
    BsSkipUtf16 = 141,

    BsGetUtf32 = 142,
    BsSkipUtf32 = 143,

    BsUtf8Size = 144,
    BsPutUtf8 = 145,

    BsUtf16Size = 146,
    BsPutUtf16 = 147,

    BsPutUtf32 = 148,

    // R13B03
    OnLoad = 149,

    // R14A
    /// @spec recv_mark Label
    /// @doc  Save the end of the message queue and the address of
    ///       the label Label so that a recv_set instruction can start
    ///       scanning the inbox from this position.
    RecvMark = 150,

    /// @spec recv_set Label
    /// @doc Check that the saved mark points to Label and set the
    ///      save pointer in the message queue to the last position
    ///      of the message queue saved by the recv_mark instruction.
    RecvSet = 151,

    /// @spec gc_bif3 Lbl Live Bif Arg1 Arg2 Arg3 Reg
    /// @doc Call the bif Bif with the arguments Arg1, Arg2 and Arg3,
    ///      and store the result in Reg.
    ///      On failure jump to Lbl.
    ///      Do a garbage collection if necessary to allocate space on the heap
    ///      for the result (saving Live number of X registers).
    GcBif3 = 152,

    // R15A
    Line = 153,

    // R17
    PutMapAssoc = 154,
    PutMapExact = 155,
    IsMap = 156,
    HasMapFields = 157,
    GetMapElements = 158,

    // OTP 20
    /// @spec is_tagged_tuple Lbl Reg N Atom
    /// @doc Test the type of Reg and jumps to Lbl if it is not a tuple.
    ///      Test the arity of Reg and jumps to Lbl if it is not N.
    ///      Test the first element of the tuple and jumps to Lbl if it is not Atom.
    IsTaggedTuple = 159,

    // OTP 21
    /// @spec build_stacktrace
    /// @doc  Given the raw stacktrace in x(0), build a cooked stacktrace suitable
    ///       for human consumption. Store it in x(0). Destroys all other registers.
    ///       Do a garbage collection if necessary to allocate space on the heap
    ///       for the result.
    BuildStacktrace = 160,

    /// @spec raw_raise
    /// @doc  This instruction works like the erlang:raise BIF, except that the
    ///       stacktrace in x(2) must be a raw stacktrace.
    ///       x(0) is the class of the exception (error, exit, or throw),
    ///       x(1) is the exception term, and x(2) is the raw stackframe.
    ///       If x(0) is not a valid class, the instruction will not throw an
    ///       exception, but store the atom 'badarg' in x(0) and execute the
    ///       next instruction.
    RawRaise = 161,

    /// @spec get_hd  Source Head
    /// @doc  Get the head (or car) part of a list (a cons cell) from Source and
    ///       put it into the register Head.
    GetHd = 162,

    /// @spec get_tl  Source Tail
    /// @doc  Get the tail (or cdr) part of a list (a cons cell) from Source and
    ///       put it into the register Tail.
    GetTl = 163,

    // OTP 22
    /// @spec put_tuple2  Destination Elements
    /// @doc  Build a tuple with the elements in the list Elements and put it
    ///       put into register Destination.
    PutTuple2 = 164,

    /// @spec bs_get_tail Ctx Dst Live
    /// @doc  Sets Dst to the tail of Ctx at the current position (similar to bs_context_to_binary
    ///       but non-destructive.)
    BsGetTail = 165,

    /// @spec bs_start_match3 Fail Bin Live Dst
    /// @doc  Starts a binary match sequence (but without "position slots")
    BsStartMatch3 = 166,

    /// @spec bs_get_position Ctx Dst Live
    /// @doc  Sets Dst to the current position of Ctx
    BsGetPosition = 167,

    /// @spec bs_set_positon Ctx Pos
    /// @doc  Sets the current position of Ctx to Pos
    BsSetPosition = 168,

    /// @spec swap Register1 Register2
    /// @doc  Swaps the contents of two registers.
    Swap = 169,
}

pub static ARITY_MAP: &'static [usize] = &[
    0, // opcode 0 does not exist
    1, // opcode: 1 (label)
    3, // opcode: 2 (func_info)
    0, // opcode: 3 (int_code_end)
    2, // opcode: 4 (call)
    3, // opcode: 5 (call_last)
    2, // opcode: 6 (call_only)
    2, // opcode: 7 (call_ext)
    3, // opcode: 8 (call_ext_last)
    2, // opcode: 9 (bif0)
    4, // opcode: 10 (bif1)
    5, // opcode: 11 (bif2)
    2, // opcode: 12 (allocate)
    3, // opcode: 13 (allocate_heap)
    2, // opcode: 14 (allocate_zero)
    3, // opcode: 15 (allocate_heap_zero)
    2, // opcode: 16 (test_heap)
    1, // opcode: 17 (init)
    1, // opcode: 18 (deallocate)
    0, // opcode: 19 (return)
    0, // opcode: 20 (send)
    0, // opcode: 21 (remove_message)
    0, // opcode: 22 (timeout)
    2, // opcode: 23 (loop_rec)
    1, // opcode: 24 (loop_rec_end)
    1, // opcode: 25 (wait)
    2, // opcode: 26 (wait_timeout)
    4, // opcode: 27 (m_plus)
    4, // opcode: 28 (m_minus)
    4, // opcode: 29 (m_times)
    4, // opcode: 30 (m_div)
    4, // opcode: 31 (int_div)
    4, // opcode: 32 (int_rem)
    4, // opcode: 33 (int_band)
    4, // opcode: 34 (int_bor)
    4, // opcode: 35 (int_bxor)
    4, // opcode: 36 (int_bsl)
    4, // opcode: 37 (int_bsr)
    3, // opcode: 38 (int_bnot)
    3, // opcode: 39 (is_lt)
    3, // opcode: 40 (is_ge)
    3, // opcode: 41 (is_eq)
    3, // opcode: 42 (is_ne)
    3, // opcode: 43 (is_eq_exact)
    3, // opcode: 44 (is_ne_exact)
    2, // opcode: 45 (is_integer)
    2, // opcode: 46 (is_float)
    2, // opcode: 47 (is_number)
    2, // opcode: 48 (is_atom)
    2, // opcode: 49 (is_pid)
    2, // opcode: 50 (is_reference)
    2, // opcode: 51 (is_port)
    2, // opcode: 52 (is_nil)
    2, // opcode: 53 (is_binary)
    2, // opcode: 54 (is_constant)
    2, // opcode: 55 (is_list)
    2, // opcode: 56 (is_nonempty_list)
    2, // opcode: 57 (is_tuple)
    3, // opcode: 58 (test_arity)
    3, // opcode: 59 (select_val)
    3, // opcode: 60 (select_tuple_arity)
    1, // opcode: 61 (jump)
    2, // opcode: 62 (catch)
    1, // opcode: 63 (catch_end)
    2, // opcode: 64 (move)
    3, // opcode: 65 (get_list)
    3, // opcode: 66 (get_tuple_element)
    3, // opcode: 67 (set_tuple_element)
    3, // opcode: 68 (put_string)
    3, // opcode: 69 (put_list)
    2, // opcode: 70 (put_tuple)
    1, // opcode: 71 (put)
    1, // opcode: 72 (badmatch)
    0, // opcode: 73 (if_end)
    1, // opcode: 74 (case_end)
    1, // opcode: 75 (call_fun)
    3, // opcode: 76 (make_fun)
    2, // opcode: 77 (is_function)
    2, // opcode: 78 (call_ext_only)
    2, // opcode: 79 (bs_start_match)
    5, // opcode: 80 (bs_get_integer)
    5, // opcode: 81 (bs_get_float)
    5, // opcode: 82 (bs_get_binary)
    4, // opcode: 83 (bs_skip_bits)
    2, // opcode: 84 (bs_test_tail)
    1, // opcode: 85 (bs_save)
    1, // opcode: 86 (bs_restore)
    2, // opcode: 87 (bs_init)
    2, // opcode: 88 (bs_final)
    5, // opcode: 89 (bs_put_integer)
    5, // opcode: 90 (bs_put_binary)
    5, // opcode: 91 (bs_put_float)
    2, // opcode: 92 (bs_put_string)
    1, // opcode: 93 (bs_need_buf)
    0, // opcode: 94 (fclearerror)
    1, // opcode: 95 (fcheckerror)
    2, // opcode: 96 (fmove)
    2, // opcode: 97 (fconv)
    4, // opcode: 98 (fadd)
    4, // opcode: 99 (fsub)
    4, // opcode: 100 (fmul)
    4, // opcode: 101 (fdiv)
    3, // opcode: 102 (fnegate)
    1, // opcode: 103 (make_fun2)
    2, // opcode: 104 (try)
    1, // opcode: 105 (try_end)
    1, // opcode: 106 (try_case)
    1, // opcode: 107 (try_case_end)
    2, // opcode: 108 (raise)
    6, // opcode: 109 (bs_init2)
    3, // opcode: 110 (bs_bits_to_bytes)
    5, // opcode: 111 (bs_add)
    1, // opcode: 112 (apply)
    2, // opcode: 113 (apply_last)
    2, // opcode: 114 (is_boolean)
    3, // opcode: 115 (is_function2)
    5, // opcode: 116 (bs_start_match2)
    7, // opcode: 117 (bs_get_integer2)
    7, // opcode: 118 (bs_get_float2)
    7, // opcode: 119 (bs_get_binary2)
    5, // opcode: 120 (bs_skip_bits2)
    3, // opcode: 121 (bs_test_tail2)
    2, // opcode: 122 (bs_save2)
    2, // opcode: 123 (bs_restore2)
    5, // opcode: 124 (gc_bif1)
    6, // opcode: 125 (gc_bif2)
    2, // opcode: 126 (bs_final2)
    2, // opcode: 127 (bs_bits_to_bytes2)
    2, // opcode: 128 (put_literal)
    2, // opcode: 129 (is_bitstr)
    1, // opcode: 130 (bs_context_to_binary)
    3, // opcode: 131 (bs_test_unit)
    4, // opcode: 132 (bs_match_string)
    0, // opcode: 133 (bs_init_writable)
    8, // opcode: 134 (bs_append)
    6, // opcode: 135 (bs_private_append)
    2, // opcode: 136 (trim)
    6, // opcode: 137 (bs_init_bits)
    5, // opcode: 138 (bs_get_utf8)
    4, // opcode: 139 (bs_skip_utf8)
    5, // opcode: 140 (bs_get_utf16)
    4, // opcode: 141 (bs_skip_utf16)
    5, // opcode: 142 (bs_get_utf32)
    4, // opcode: 143 (bs_skip_utf32)
    3, // opcode: 144 (bs_utf8_size)
    3, // opcode: 145 (bs_put_utf8)
    3, // opcode: 146 (bs_utf16_size)
    3, // opcode: 147 (bs_put_utf16)
    3, // opcode: 148 (bs_put_utf32)
    0, // opcode: 149 (on_load)
    1, // opcode: 150 (recv_mark)
    1, // opcode: 151 (recv_set)
    7, // opcode: 152 (gc_bif3)
    1, // opcode: 153 (line)
    5, // opcode: 154 (put_map_assoc)
    5, // opcode: 155 (put_map_exact)
    2, // opcode: 156 (is_map)
    3, // opcode: 157 (has_map_fields)
    3, // opcode: 158 (get_map_elements)
    4, // opcode: 159 (is_tagged_tuple)
    0, // opcode: 160 (build_stacktrace)
    0, // opcode: 161 (raw_raise)
    2, // opcode: 162 (get_hd)
    2, // opcode: 163 (get_tl)
    2, // opcode: 164 (put_tuple_2)
    3, // opcode: 165 (bs_get_tail)
    4, // opcode: 166 (bs_start_match_3)
    3, // opcode: 167 (bs_get_position)
    2, // opcode: 168 (bs_set_position)
    2, // opcode: 169 (swap)
];

#[inline]
pub fn opcode_arity(opcode: u8) -> usize {
    ARITY_MAP[opcode as usize]
}

pub fn to_opcode(opcode: u8) -> Opcode {
    unsafe { ::std::mem::transmute(opcode) }
}
